#!/usr/bin/env python

import rospy, time
from geometry_msgs.msg import Twist
from nav_msgs.msg import Path
from math import pi, sin, cos, atan2, sqrt
from nav_msgs.msg import Odometry
import math

WP_SIZE = 0.5

class Server:
    def __init__(self, current_time=None):
        self.waypoint = False
        self.sample_time = 0.00
        self.current_time = current_time if current_time is not None else time.time()
        self.last_time = self.current_time

        self.vel_publisher = rospy.Publisher('spot/cmd_vel', Twist, queue_size = 10)
        self.vel_msg = Twist()

        self.waypoint_subscriber = rospy.Subscriber('/dsl_grid3d/optpath', Path, self.waypoint_callback)

        # Windup Guard
        self.int_error = 0.0
        self.windup_guard = 20
        self.runOnce = True
        self.writeOnce = True

        self.degree_to_rad = float(pi / 180.0)
        self.R = 6367


        self.x_r = 0.0
        self.y_r = 0.0 #-0.6
        self.z_r = 0.0 #3

        self.path = Path()
        self.wp_index = 0

        #x
        self.vel_x = 0.0
        self.last_error_x = 0.0

        self.PTerm_x = 0.0
        self.DTerm_x = 0.0
        self.ITerm_x = 0.0

        self.kP_x = 0.25	# 0.69
        self.kI_x = 0.00000 #0.0025 	# 0.00015
        self.kD_x = 0.001 #31 #.291
        #y
        self.vel_y = 0.0
        self.last_error_y = 0.0

        self.PTerm_y = 0.0
        self.DTerm_y = 0.0
        self.ITerm_y = 0.0

        self.kP_y = 0.25	# 0.69
        self.kI_y = 0.00000 #0.0025 	# 0.00015
        self.kD_y = 0.001 #342 #0.241

        #z
        self.vel_z = 0.0
        self.last_error_z = 0.0

        self.PTerm_z = 0.0
        self.DTerm_z = 0.0
        self.ITerm_z = 0.0

        self.kP_z = 0.0		# 1.32
        self.kI_z = 0.0	# 0.0003
        self.kD_z = 0.0	# 10.2

		
    def waypoint_callback(self, msg):
        print("geting waypoints")
        print(msg)
        self.wp_index = 0
        self.path = msg
        self.x_r = msg.poses[self.wp_index].pose.position.x
        self.y_r = msg.poses[self.wp_index].pose.position.y
        self.z_r = msg.poses[self.wp_index].pose.position.z
        self.waypoint = True


    def read_callback(self, msg):
        self.position_messages = msg
        #print("my postition")
        #print(msg)
        if(self.waypoint):
            self.control()

    def control(self, current_time=None):
        if(self.runOnce):
#			self.x_r = x_c
#			self.y_r = y_c
#			self.z_r = z_c
            self.runOnce = False

        x_c = self.position_messages.pose.pose.position.x
        y_c = self.position_messages.pose.pose.position.y
        z_c = self.position_messages.pose.pose.position.z
        q_x = self.position_messages.pose.pose.orientation.x
        q_y = self.position_messages.pose.pose.orientation.y
        q_z = self.position_messages.pose.pose.orientation.z
        q_w = self.position_messages.pose.pose.orientation.w

# at wp?
        if ((x_c - self.x_r) * (x_c - self.x_r)  + (y_c - self.y_r) * (y_c - self.y_r) < WP_SIZE):
            if(self.wp_index < len(self.path.poses) -1 ):
                self.wp_index = self.wp_index + 1
            self.x_r = self.path.poses[self.wp_index].pose.position.x
            self.y_r = self.path.poses[self.wp_index].pose.position.y
            self.z_r = self.path.poses[self.wp_index].pose.position.z

        yaw_z = math.atan2(2.0*(q_w * q_z + q_x * q_y), 1.0 - 2.0 * (q_y * q_y + q_z * q_z))


#error
        error_x = self.x_r - x_c
        error_y = self.y_r - y_c
        error_z = self.z_r - z_c
#time
        self.current_time = current_time if current_time is not None else time.time()
        delta_time = self.current_time - self.last_time
#d-error
        delta_error_x = error_x - self.last_error_x
        delta_error_y = error_y - self.last_error_y
        delta_error_z = error_z - self.last_error_z

        if (delta_time >= self.sample_time):
#P-term
            self.PTerm_x = self.kP_x * error_x
            self.PTerm_y = self.kP_y * error_y
            self.PTerm_z = self.kP_z * error_z
#I-term
            self.ITerm_x += error_x * delta_time
            if (self.ITerm_x < -self.windup_guard):
                    self.ITerm_x = -self.windup_guard
            elif (self.ITerm_x > self.windup_guard):
                    self.ITerm_x = self.windup_guard

            self.ITerm_y += error_y * delta_time
            if (self.ITerm_y < -self.windup_guard):
                    self.ITerm_y = -self.windup_guard
            elif (self.ITerm_y > self.windup_guard):
                    self.ITerm_y = self.windup_guard

            self.ITerm_z += error_z * delta_time
            if (self.ITerm_z < -self.windup_guard):
                    self.ITerm_z = -self.windup_guard
            elif (self.ITerm_z > self.windup_guard):
                    self.ITerm_z = self.windup_guard
#D-term
            self.DTerm_x = 0.0
            if delta_time > 0:
                    self.DTerm_x = delta_error_x / delta_time

            self.DTerm_y = 0.0
            if delta_time > 0:
                    self.DTerm_y = delta_error_y / delta_time

            self.DTerm_z = 0.0
            if delta_time > 0:
                    self.DTerm_z = delta_error_z / delta_time
# Remember last time and last error for next calculation
            self.last_time = self.current_time
            self.last_error_x = error_x
            self.last_error_y = error_y
            self.last_error_z = error_z

            self.vel_x = self.PTerm_x + (self.kI_x * self.ITerm_x) + (self.kD_x * self.DTerm_x)
            self.vel_y = self.PTerm_y + (self.kI_y * self.ITerm_y) + (self.kD_y * self.DTerm_y)
            self.vel_z = self.PTerm_z + (self.kI_z * self.ITerm_z) + (self.kD_z * self.DTerm_z)

        print("self.vel_x", self.vel_x, "self.vel_y: ", self.vel_y, "vel_z: ", self.vel_z)
    #publish
        #self.vel_msg.linear.x = self.vel_x * 0 + self.vel_y * (1)
        #self.vel_msg.linear.y = self.vel_x * -1 + self.vel_y * 0
        x_t = self.vel_x * cos(yaw_z) + self.vel_y * sin(yaw_z)
        y_t = -self.vel_x * sin(yaw_z) + self.vel_y * cos(yaw_z)

        self.vel_msg.linear.x = x_t
        self.vel_msg.linear.y = y_t
        #self.vel_msg.linear.x = self.vel_x
        #self.vel_msg.linear.y = self.vel_y

        self.vel_msg.linear.z = self.vel_z
        self.vel_publisher.publish(self.vel_msg)

if __name__ == "__main__":
    try:
        rospy.init_node('position_control', anonymous=True)
        rospy.loginfo("Starting...")
        rospy.Rate(5)	#10Hz

        server = Server()

        while not rospy.is_shutdown():
            rospy.Subscriber("/spot/odometry", Odometry, server.read_callback)
            rospy.spin()

        rospy.loginfo("Reading finished...")
    except rospy.ROSInterruptException:
        pass
